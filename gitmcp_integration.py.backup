#!/usr/bin/env python3
"""
Integra√ß√£o com GitMCP - Acesso inteligente √† documenta√ß√£o GitHub
Permite acesso direto √† documenta√ß√£o e c√≥digo de reposit√≥rios GitHub
Vers√£o adaptada que funciona com API do GitHub
"""

import os
import sys
import json
import requests
import base64
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse

class GitHubDocsClient:
    """
    Cliente para acesso √† documenta√ß√£o GitHub
    Usa API do GitHub para obter README e documenta√ß√£o
    """

    def __init__(self, github_token: str = None):
        """
        Inicializa o cliente GitHub

        Args:
            github_token: Token do GitHub (opcional, aumenta limite de requests)
        """
        self.base_url = "https://api.github.com"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Algoritmos-Visualizador/1.0',
            'Accept': 'application/vnd.github.v3+json'
        })

        if github_token:
            self.session.headers['Authorization'] = f'token {github_token}'
        elif os.getenv('GITHUB_TOKEN'):
            self.session.headers['Authorization'] = f'token {os.getenv("GITHUB_TOKEN")}'

    def is_available(self) -> bool:
        """
        Verifica se a API do GitHub est√° dispon√≠vel

        Returns:
            bool: True se a API estiver acess√≠vel
        """
        try:
            response = self.session.get(f"{self.base_url}/rate_limit", timeout=5)
            return response.status_code == 200
        except:
            return False

    def get_repository_info(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Obt√©m informa√ß√µes b√°sicas de um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com informa√ß√µes do reposit√≥rio
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            return {
                "status": "success",
                "name": data.get("name"),
                "full_name": data.get("full_name"),
                "description": data.get("description"),
                "language": data.get("language"),
                "stars": data.get("stargazers_count"),
                "forks": data.get("forks_count"),
                "topics": data.get("topics", []),
                "html_url": data.get("html_url"),
                "updated_at": data.get("updated_at")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao obter informa√ß√µes do reposit√≥rio"
            }

    def get_readme(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Obt√©m o README de um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com conte√∫do do README
        """
        try:
            # Tenta primeiro README.md
            url = f"{self.base_url}/repos/{owner}/{repo}/readme"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            content = data.get("content", "")

            # Decodifica base64 se necess√°rio
            if data.get("encoding") == "base64":
                content = base64.b64decode(content).decode('utf-8')

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "filename": data.get("name", "README.md"),
                "content": content,
                "size": data.get("size", 0),
                "download_url": data.get("download_url")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao obter README"
            }

    def search_code(self, owner: str, repo: str, query: str,
                   language: str = None, max_results: int = 5) -> Dict[str, Any]:
        """
        Busca c√≥digo em um reposit√≥rio usando a API do GitHub

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            query: Termo de busca no c√≥digo
            language: Linguagem de programa√ß√£o (opcional)
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Dict com resultados da busca de c√≥digo
        """
        try:
            url = f"{self.base_url}/search/code"
            params = {
                'q': f'repo:{owner}/{repo} {query}',
                'per_page': max_results
            }

            if language:
                params['q'] += f' language:{language}'

            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()

            data = response.json()
            items = data.get("items", [])

            # Processa os resultados
            results = []
            for item in items:
                results.append({
                    "name": item.get("name"),
                    "path": item.get("path"),
                    "url": item.get("html_url"),
                    "repository": item.get("repository", {}).get("full_name"),
                    "score": item.get("score", 0)
                })

            return {
                "status": "success",
                "query": query,
                "repository": f"{owner}/{repo}",
                "language": language,
                "results": results,
                "total_results": len(results),
                "github_total": data.get("total_count", 0)
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "query": query,
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao buscar c√≥digo"
            }

    def get_file_content(self, owner: str, repo: str, path: str) -> Dict[str, Any]:
        """
        Obt√©m conte√∫do de um arquivo espec√≠fico

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            path: Caminho do arquivo

        Returns:
            Dict com conte√∫do do arquivo
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            content = data.get("content", "")

            # Decodifica base64 se necess√°rio
            if data.get("encoding") == "base64":
                content = base64.b64decode(content).decode('utf-8')

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "path": path,
                "name": data.get("name"),
                "content": content,
                "size": data.get("size", 0),
                "download_url": data.get("download_url")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "path": path,
                "error": str(e),
                "message": "Erro ao obter conte√∫do do arquivo"
            }


class GitMCPIntegration:
    """
    Integra√ß√£o completa para acesso √† documenta√ß√£o GitHub
    """

    def __init__(self):
        self.client = GitHubDocsClient()
        self.cache = {}

    def buscar_documentacao_algoritmo(self, algoritmo: str,
                                    linguagem: str = "python") -> Dict[str, Any]:
        """
        Busca documenta√ß√£o espec√≠fica para algoritmos

        Args:
            algoritmo: Nome do algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com documenta√ß√£o encontrada
        """
        print(f"üîç Buscando documenta√ß√£o para: {algoritmo} ({linguagem})")

        # Mapeamento de algoritmos para reposit√≥rios relevantes
        repos_map = {
            "sort": ["TheAlgorithms/Python", "keon/algorithms"],
            "search": ["TheAlgorithms/Python", "keon/algorithms"],
            "graph": ["TheAlgorithms/Python", "networkx/networkx"],
            "tree": ["TheAlgorithms/Python", "keon/algorithms"],
            "dynamic": ["TheAlgorithms/Python", "keon/algorithms"],
            "machine_learning": ["scikit-learn/scikit-learn", "tensorflow/tensorflow"]
        }

        algoritmo_key = algoritmo.lower().replace(" ", "_")
        repos = repos_map.get(algoritmo_key, ["TheAlgorithms/Python"])

        resultados = []

        for repo_full in repos:
            if "/" in repo_full:
                owner, repo = repo_full.split("/", 1)
            else:
                continue

            # Obt√©m informa√ß√µes do reposit√≥rio
            repo_info = self.client.get_repository_info(owner, repo)
            readme = self.client.get_readme(owner, repo)

            if repo_info["status"] == "success":
                resultados.append({
                    "repositorio": repo_full,
                    "info": repo_info,
                    "readme": readme if readme["status"] == "success" else None
                })

        return {
            "algoritmo": algoritmo,
            "linguagem": linguagem,
            "resultados": resultados,
            "total_encontrados": len(resultados)
        }

    def obter_exemplos_codigo(self, conceito: str, linguagem: str = "python") -> Dict[str, Any]:
        """
        Obt√©m exemplos de c√≥digo para um conceito espec√≠fico

        Args:
            conceito: Conceito ou algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com exemplos de c√≥digo
        """
        print(f"üíª Buscando exemplos para: {conceito} ({linguagem})")

        # Busca nos reposit√≥rios mais relevantes
        repos = ["TheAlgorithms/Python", "keon/algorithms"]

        exemplos = []

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)

            # Busca c√≥digo
            code_search = self.client.search_code(
                owner, repo, conceito, language=linguagem, max_results=5
            )

            if code_search["status"] == "success" and code_search["results"]:
                # Para cada resultado, obt√©m o conte√∫do completo
                for result in code_search["results"]:
                    file_content = self.client.get_file_content(owner, repo, result["path"])
                    if file_content["status"] == "success":
                        exemplos.append({
                            "repositorio": repo_full,
                            "arquivo": result["name"],
                            "caminho": result["path"],
                            "url": result["url"],
                            "conteudo": file_content["content"],
                            "score": result["score"]
                        })

        return {
            "conceito": conceito,
            "linguagem": linguagem,
            "exemplos": exemplos[:10],  # Limita a 10 exemplos
            "total_exemplos": len(exemplos)
        }

    def comparar_implementacoes(self, algoritmo: str) -> Dict[str, Any]:
        """
        Compara diferentes implementa√ß√µes de um algoritmo

        Args:
            algoritmo: Nome do algoritmo

        Returns:
            Dict com compara√ß√µes de implementa√ß√µes
        """
        print(f"üîÑ Comparando implementa√ß√µes de: {algoritmo}")

        repos = ["TheAlgorithms/Python", "keon/algorithms"]

        comparacoes = {}

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)
            linguagem = "python"  # Ambos s√£o Python

            # Busca implementa√ß√£o
            search = self.client.search_code(owner, repo, algoritmo, max_results=3)

            if search["status"] == "success" and search["results"]:
                if linguagem not in comparacoes:
                    comparacoes[linguagem] = []

                for result in search["results"]:
                    file_content = self.client.get_file_content(owner, repo, result["path"])
                    if file_content["status"] == "success":
                        comparacoes[linguagem].append({
                            "repositorio": repo_full,
                            "arquivo": result["name"],
                            "conteudo": file_content["content"],
                            "url": result["url"]
                        })

        return {
            "algoritmo": algoritmo,
            "comparacoes": comparacoes,
            "linguagens": list(comparacoes.keys())
        }


# Inst√¢ncia global para uso no projeto
github_client = GitHubDocsClient()
github_integration = GitMCPIntegration()


def testar_integracao():
    """Testa a integra√ß√£o com GitHub API"""
    print("üß™ Testando Integra√ß√£o GitHub API")
    print("=" * 40)

    # Testa disponibilidade
    print(f"GitHub API dispon√≠vel: {github_client.is_available()}")

    if github_client.is_available():
        # Testa busca de reposit√≥rio
        print("\nüìö Testando busca de reposit√≥rio...")
        repo = github_client.get_repository_info("TheAlgorithms", "Python")
        print(f"Status: {repo['status']}")
        if repo['status'] == 'success':
            print(f"üìñ Reposit√≥rio: {repo.get('full_name')}")
            print(f"‚≠ê Stars: {repo.get('stars')}")
            print(f"üìù Descri√ß√£o: {repo.get('description', 'N/A')[:100]}...")

        # Testa busca de README
        print("\nüìÑ Testando busca de README...")
        readme = github_client.get_readme("TheAlgorithms", "Python")
        print(f"Status: {readme['status']}")
        if readme['status'] == 'success':
            content = readme.get('content', '')
            print(f"üìè Tamanho: {len(content)} caracteres")
            print(f"üìÑ Conte√∫do (primeiras 200 chars): {content[:200]}...")

        # Testa busca de c√≥digo
        print("\nüíª Testando busca de c√≥digo...")
        code = github_client.search_code("TheAlgorithms", "Python", "bubble sort", max_results=3)
        print(f"Status: {code['status']}")
        print(f"Resultados encontrados: {code.get('total_results', 0)}")

        # Testa integra√ß√£o espec√≠fica
        print("\nüîó Testando integra√ß√£o de algoritmos...")
        integration = GitMCPIntegration()
        exemplos = integration.obter_exemplos_codigo("quick sort")
        print(f"Exemplos encontrados: {exemplos.get('total_exemplos', 0)}")

    else:
        print("GitHub API n√£o est√° dispon√≠vel no momento")
        print("Verifique sua conex√£o com a internet")


if __name__ == "__main__":
    testar_integracao()

import os
import sys
import json
import requests
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse

class GitMCPClient:
    """
    Cliente para integra√ß√£o com GitMCP
    Permite acesso inteligente √† documenta√ß√£o GitHub
    """

    def __init__(self, base_url: str = "https://gitmcp.io"):
        """
        Inicializa o cliente GitMCP

        Args:
            base_url: URL base do GitMCP server
        """
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Algoritmos-Visualizador/1.0',
            'Accept': 'application/json'
        })

    def is_available(self) -> bool:
        """
        Verifica se o GitMCP server est√° dispon√≠vel

        Returns:
            bool: True se o servidor estiver acess√≠vel
        """
        try:
            response = self.session.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False

    def get_repository_url(self, owner: str, repo: str) -> str:
        """
        Gera URL espec√≠fica para um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            str: URL do GitMCP para o reposit√≥rio
        """
        return f"{self.base_url}/{owner}/{repo}"

    def get_generic_url(self) -> str:
        """
        Retorna URL gen√©rica para acesso din√¢mico

        Returns:
            str: URL gen√©rica do GitMCP
        """
        return f"{self.base_url}/docs"

    def search_documentation(self, owner: str, repo: str, query: str,
                           max_results: int = 5) -> Dict[str, Any]:
        """
        Busca na documenta√ß√£o de um reposit√≥rio espec√≠fico

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            query: Termo de busca
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Dict com resultados da busca
        """
        try:
            search_url = f"{self.get_repository_url(owner, repo)}/search"
            params = {
                'q': query,
                'limit': max_results
            }

            response = self.session.get(search_url, params=params, timeout=10)
            response.raise_for_status()

            return {
                "status": "success",
                "query": query,
                "repository": f"{owner}/{repo}",
                "results": response.json().get("results", []),
                "total_results": len(response.json().get("results", []))
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "query": query,
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao buscar documenta√ß√£o"
            }

    def fetch_documentation(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Busca documenta√ß√£o principal de um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com documenta√ß√£o do reposit√≥rio
        """
        try:
            docs_url = f"{self.get_repository_url(owner, repo)}/docs"

            response = self.session.get(docs_url, timeout=15)
            response.raise_for_status()

            data = response.json()

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "title": data.get("title", f"{owner}/{repo}"),
                "description": data.get("description", ""),
                "content": data.get("content", ""),
                "sections": data.get("sections", []),
                "last_updated": data.get("last_updated")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao buscar documenta√ß√£o principal"
            }

    def search_code(self, owner: str, repo: str, query: str,
                   language: str = None, max_results: int = 5) -> Dict[str, Any]:
        """
        Busca c√≥digo em um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            query: Termo de busca no c√≥digo
            language: Linguagem de programa√ß√£o (opcional)
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Dict com resultados da busca de c√≥digo
        """
        try:
            code_url = f"{self.get_repository_url(owner, repo)}/code"
            params = {
                'q': query,
                'limit': max_results
            }

            if language:
                params['language'] = language

            response = self.session.get(code_url, params=params, timeout=10)
            response.raise_for_status()

            return {
                "status": "success",
                "query": query,
                "repository": f"{owner}/{repo}",
                "language": language,
                "results": response.json().get("results", []),
                "total_results": len(response.json().get("results", []))
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "query": query,
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao buscar c√≥digo"
            }

    def get_popular_repositories(self, topic: str = "python",
                               sort: str = "stars", max_results: int = 10) -> List[Dict]:
        """
        Busca reposit√≥rios populares por t√≥pico

        Args:
            topic: T√≥pico de busca (python, algorithms, etc.)
            sort: Ordena√ß√£o (stars, updated, etc.)
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Lista de reposit√≥rios populares
        """
        try:
            # Busca atrav√©s da API do GitHub
            github_api = "https://api.github.com/search/repositories"
            params = {
                'q': f'topic:{topic}',
                'sort': sort,
                'order': 'desc',
                'per_page': max_results
            }

            response = requests.get(github_api, params=params, timeout=10)
            response.raise_for_status()

            repos = []
            for item in response.json().get("items", []):
                repos.append({
                    "name": item["name"],
                    "full_name": item["full_name"],
                    "owner": item["owner"]["login"],
                    "description": item["description"] or "",
                    "stars": item["stargazers_count"],
                    "language": item["language"],
                    "url": item["html_url"],
                    "gitmcp_url": self.get_repository_url(item["owner"]["login"], item["name"])
                })

            return repos

        except Exception as e:
            return [{
                "error": str(e),
                "message": "Erro ao buscar reposit√≥rios populares"
            }]

    def get_badge_info(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Obt√©m informa√ß√µes do badge GitMCP para um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com informa√ß√µes do badge
        """
        try:
            badge_url = f"{self.base_url}/badge/{owner}/{repo}"

            response = self.session.get(badge_url, timeout=5)
            response.raise_for_status()

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "badge_data": response.json(),
                "badge_url": f"https://img.shields.io/endpoint?url={badge_url}",
                "chat_url": self.get_repository_url(owner, repo)
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao obter informa√ß√µes do badge"
            }


class GitMCPIntegration:
    """
    Integra√ß√£o completa do GitMCP com o sistema de algoritmos
    """

    def __init__(self):
        self.client = GitMCPClient()
        self.cache = {}

    def buscar_documentacao_algoritmo(self, algoritmo: str,
                                    linguagem: str = "python") -> Dict[str, Any]:
        """
        Busca documenta√ß√£o espec√≠fica para algoritmos

        Args:
            algoritmo: Nome do algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com documenta√ß√£o encontrada
        """
        # Mapeamento de algoritmos para reposit√≥rios relevantes
        repos_map = {
            "sort": ["TheAlgorithms/Python", "keon/algorithms"],
            "search": ["TheAlgorithms/Python", "keon/algorithms"],
            "graph": ["TheAlgorithms/Python", "networkx/networkx"],
            "tree": ["TheAlgorithms/Python", "keon/algorithms"],
            "dynamic": ["TheAlgorithms/Python", "keon/algorithms"],
            "machine_learning": ["scikit-learn/scikit-learn", "tensorflow/tensorflow"]
        }

        algoritmo_key = algoritmo.lower().replace(" ", "_")
        repos = repos_map.get(algoritmo_key, ["TheAlgorithms/Python"])

        resultados = []

        for repo_full in repos:
            if "/" in repo_full:
                owner, repo = repo_full.split("/", 1)
            else:
                continue

            # Busca documenta√ß√£o
            docs = self.client.fetch_documentation(owner, repo)
            if docs["status"] == "success":
                # Busca espec√≠fica no algoritmo
                search = self.client.search_documentation(
                    owner, repo, f"{algoritmo} {linguagem}", max_results=3
                )

                if search["status"] == "success" and search["results"]:
                    resultados.append({
                        "repositorio": repo_full,
                        "documentacao": docs,
                        "resultados_busca": search["results"]
                    })

        return {
            "algoritmo": algoritmo,
            "linguagem": linguagem,
            "resultados": resultados,
            "total_encontrados": len(resultados)
        }

    def obter_exemplos_codigo(self, conceito: str, linguagem: str = "python") -> Dict[str, Any]:
        """
        Obt√©m exemplos de c√≥digo para um conceito espec√≠fico

        Args:
            conceito: Conceito ou algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com exemplos de c√≥digo
        """
        # Busca nos reposit√≥rios mais relevantes
        repos = ["TheAlgorithms/Python", "keon/algorithms"]

        exemplos = []

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)

            # Busca c√≥digo
            code_search = self.client.search_code(
                owner, repo, conceito, language=linguagem, max_results=5
            )

            if code_search["status"] == "success" and code_search["results"]:
                exemplos.extend(code_search["results"])

        return {
            "conceito": conceito,
            "linguagem": linguagem,
            "exemplos": exemplos[:10],  # Limita a 10 exemplos
            "total_exemplos": len(exemplos)
        }

    def comparar_implementacoes(self, algoritmo: str) -> Dict[str, Any]:
        """
        Compara diferentes implementa√ß√µes de um algoritmo

        Args:
            algoritmo: Nome do algoritmo

        Returns:
            Dict com compara√ß√µes de implementa√ß√µes
        """
        repos = ["TheAlgorithms/Python", "keon/algorithms", "TheAlgorithms/Java"]

        comparacoes = {}

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)
            linguagem = repo  # Python, Java, etc.

            # Busca implementa√ß√£o
            search = self.client.search_code(owner, repo, algoritmo, max_results=3)

            if search["status"] == "success" and search["results"]:
                comparacoes[linguagem] = {
                    "repositorio": repo_full,
                    "implementacoes": search["results"]
                }

        return {
            "algoritmo": algoritmo,
            "comparacoes": comparacoes,
            "linguagens": list(comparacoes.keys())
        }


# Inst√¢ncia global para uso no projeto
github_client = GitHubDocsClient()
github_integration = GitMCPIntegration()

# Manter compatibilidade com c√≥digo existente
gitmcp_client = github_client
gitmcp_integration = github_integration


def testar_integracao():
    """Testa a integra√ß√£o com GitMCP"""
    print("üß™ Testando Integra√ß√£o GitMCP")
    print("=" * 40)

    # Testa disponibilidade
    print(f"GitMCP dispon√≠vel: {gitmcp_client.is_available()}")

    if gitmcp_client.is_available():
        # Testa busca de documenta√ß√£o
        print("\nüìö Testando busca de documenta√ß√£o...")
        docs = gitmcp_client.fetch_documentation("TheAlgorithms", "Python")
        print(f"Status: {docs['status']}")
        if docs['status'] == 'success':
            print(f"T√≠tulo: {docs.get('title', 'N/A')}")
            print(f"Descri√ß√£o: {docs.get('description', 'N/A')[:100]}...")

        # Testa busca de c√≥digo
        print("\nüíª Testando busca de c√≥digo...")
        code = gitmcp_client.search_code("TheAlgorithms", "Python", "bubble sort", max_results=3)
        print(f"Status: {code['status']}")
        print(f"Resultados encontrados: {code.get('total_results', 0)}")

        # Testa integra√ß√£o espec√≠fica
        print("\nüîó Testando integra√ß√£o de algoritmos...")
        integration = GitMCPIntegration()
        exemplos = integration.obter_exemplos_codigo("quick sort")
        print(f"Exemplos encontrados: {exemplos.get('total_exemplos', 0)}")

    else:
        print("GitMCP n√£o est√° dispon√≠vel no momento")
        print("Verifique sua conex√£o com a internet")


if __name__ == "__main__":
    testar_integracao()
