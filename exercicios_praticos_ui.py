"""
üéØ INTERFACE DE EXERC√çCIOS PR√ÅTICOS INTERATIVOS
==============================================

Interface Streamlit para exerc√≠cios pr√°ticos com valida√ß√£o
em tempo real e feedback imediato.
"""

import streamlit as st
import time
import random
from typing import Any, Dict
from sistema_exercicios_praticos import (
    sistema_exercicios,
    Exercicio,
    TipoExercicio,
    Dificuldade,
    SessaoExercicio
)

def render_exercicios_praticos():
    """Renderiza a p√°gina principal de exerc√≠cios pr√°ticos"""

    st.markdown("""
    ## üéØ Exerc√≠cios Pr√°ticos Interativos

    ### Pratique e consolide seu conhecimento

    Resolva exerc√≠cios interativos com **valida√ß√£o em tempo real**,
    **feedback imediato** e **dicas contextuais** para aprender fazendo.
    """)

    # Tabs principais
    tab1, tab2, tab3, tab4 = st.tabs([
        "üìù Praticar Exerc√≠cios",
        "üéØ Por Conceito",
        "üìä Meu Desempenho",
        "üèÜ Conquistas"
    ])

    with tab1:
        render_pratica_exercicios()

    with tab2:
        render_exercicios_por_conceito()

    with tab3:
        render_desempenho_usuario()

    with tab4:
        render_conquistas()

def render_pratica_exercicios():
    """Renderiza a interface de pr√°tica de exerc√≠cios"""

    st.markdown("### üìù Pr√°tica de Exerc√≠cios")

    # Filtros
    col1, col2, col3 = st.columns(3)

    with col1:
        dificuldade_filtro = st.selectbox(
            "Dificuldade:",
            ["Todas"] + [d.value for d in Dificuldade],
            key="dif_exercicios"
        )

    with col2:
        tipo_filtro = st.selectbox(
            "Tipo:",
            ["Todos"] + [t.value for t in TipoExercicio],
            key="tipo_exercicios"
        )

    with col3:
        modo_aleatorio = st.checkbox("Modo Aleat√≥rio", value=True)

    # Filtrar exerc√≠cios
    exercicios_filtrados = list(sistema_exercicios.exercicios.values())

    if dificuldade_filtro != "Todas":
        exercicios_filtrados = [
            ex for ex in exercicios_filtrados
            if ex.dificuldade.value == dificuldade_filtro
        ]

    if tipo_filtro != "Todos":
        exercicios_filtrados = [
            ex for ex in exercicios_filtrados
            if ex.tipo.value == tipo_filtro
        ]

    if not exercicios_filtrados:
        st.warning("Nenhum exerc√≠cio encontrado com os filtros selecionados.")
        return

    # Selecionar exerc√≠cio
    if modo_aleatorio:
        exercicio_selecionado = random.choice(exercicios_filtrados)
    else:
        exercicio_nomes = [ex.titulo for ex in exercicios_filtrados]
        exercicio_idx = st.selectbox(
            "Selecione um exerc√≠cio:",
            range(len(exercicio_nomes)),
            format_func=lambda x: exercicio_nomes[x]
        )
        exercicio_selecionado = exercicios_filtrados[exercicio_idx]

    # Iniciar sess√£o se necess√°rio
    if 'sessao_atual' not in st.session_state or \
       st.session_state.sessao_atual.exercicio_id != exercicio_selecionado.id:

        sessao = sistema_exercicios.iniciar_sessao_exercicio(exercicio_selecionado.id)
        if sessao:
            st.session_state.sessao_atual = sessao
            st.session_state.tentativa_atual = 1
            st.session_state.resposta_submetida = False
            st.session_state.feedback = None

    # Exibir exerc√≠cio
    render_exercicio_interativo(exercicio_selecionado)

def render_exercicio_interativo(exercicio: Exercicio):
    """Renderiza um exerc√≠cio espec√≠fico de forma interativa"""

    # Cabe√ßalho do exerc√≠cio
    st.markdown(f"## {exercicio.titulo}")
    st.markdown(f"*{exercicio.descricao}*")

    # M√©tricas
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Dificuldade", exercicio.dificuldade.value.title())
    with col2:
        st.metric("Tipo", exercicio.tipo.value.replace('_', ' ').title())
    with col3:
        st.metric("Tempo Estimado", f"{exercicio.tempo_estimado}min")

    # Enunciado
    st.markdown("### üìã Enunciado")
    st.write(exercicio.enunciado)

    # Interface baseada no tipo de exerc√≠cio
    resposta_usuario = render_interface_exercicio(exercicio)

    # Controles de resposta
    col1, col2, col3 = st.columns([1, 1, 2])

    with col1:
        if st.button("üí° Dica", key=f"dica_{exercicio.id}"):
            dica = sistema_exercicios.obter_dica(
                exercicio.id,
                st.session_state.get('tentativa_atual', 1)
            )
            if dica:
                st.info(f"üí° **Dica:** {dica}")
            else:
                st.warning("N√£o h√° mais dicas dispon√≠veis.")

    with col2:
        if st.button("üîÑ Reiniciar", key=f"reiniciar_{exercicio.id}"):
            # Reiniciar sess√£o
            if 'sessao_atual' in st.session_state:
                del st.session_state.sessao_atual
            st.session_state.tentativa_atual = 1
            st.session_state.resposta_submetida = False
            st.session_state.feedback = None
            st.rerun()

    with col3:
        submit_disabled = resposta_usuario is None or st.session_state.get('resposta_submetida', False)
        if st.button(
            "‚úÖ Submeter Resposta",
            disabled=submit_disabled,
            key=f"submit_{exercicio.id}"
        ):
            # Validar resposta
            feedback = sistema_exercicios.validar_resposta(
                st.session_state.sessao_atual.exercicio_id,
                resposta_usuario
            )
            st.session_state.feedback = feedback
            st.session_state.resposta_submetida = True

    # Exibir feedback
    if st.session_state.get('feedback'):
        render_feedback(st.session_state.feedback, exercicio)

def render_interface_exercicio(exercicio: Exercicio) -> Any:
    """Renderiza a interface espec√≠fica para cada tipo de exerc√≠cio"""

    if exercicio.tipo == TipoExercicio.MULTIPLA_ESCOLHA:
        opcoes = exercicio.dados_exercicio["opcoes"]
        return st.radio(
            "Selecione a resposta correta:",
            options=range(len(opcoes)),
            format_func=lambda x: opcoes[x],
            key=f"resposta_{exercicio.id}"
        )

    elif exercicio.tipo == TipoExercicio.VERDADEIRO_FALSO:
        afirmacoes = exercicio.dados_exercicio["afirmacoes"]
        respostas = []
        for i, afirmacao in enumerate(afirmacoes):
            resposta = st.radio(
                afirmacao,
                ["Verdadeiro", "Falso"],
                key=f"afirmacao_{i}_{exercicio.id}"
            )
            respostas.append(resposta == "Verdadeiro")
        return respostas

    elif exercicio.tipo == TipoExercicio.ORDENAR_PASSOS:
        passos = exercicio.dados_exercicio["passos"]
        st.write("Arraste para ordenar os passos:")
        ordem_atual = st.multiselect(
            "Ordene os passos (selecione em ordem):",
            options=range(len(passos)),
            format_func=lambda x: passos[x],
            default=list(range(len(passos))),
            key=f"ordem_{exercicio.id}"
        )
        return ordem_atual

    elif exercicio.tipo == TipoExercicio.COMPLEXIDADE_ANALISE:
        abordagens = exercicio.dados_exercicio["abordagens"]
        complexidades = exercicio.dados_exercicio["complexidades"]

        st.write("Associe cada abordagem √† sua complexidade:")
        respostas = {}
        for i, abordagem in enumerate(abordagens):
            complexidade = st.selectbox(
                f"Complexidade de: {abordagem}",
                complexidades,
                key=f"complex_{i}_{exercicio.id}"
            )
            respostas[abordagem.lower().replace(' ', '_')] = complexidade
        return respostas

    elif exercicio.tipo == TipoExercicio.DEBUGGING:
        st.code(exercicio.dados_exercicio["codigo"], language="python")
        opcoes_bug = exercicio.dados_exercicio["opcoes_bug"]
        return st.radio(
            "Qual √© o problema no c√≥digo?",
            options=range(len(opcoes_bug)),
            format_func=lambda x: opcoes_bug[x],
            key=f"debug_{exercicio.id}"
        )

    return None

def render_feedback(feedback: Dict[str, Any], exercicio: Exercicio):
    """Renderiza o feedback da resposta"""

    if feedback["correta"]:
        st.success("üéâ **Correto!** Parab√©ns!")

        # Exibir explica√ß√£o
        with st.expander("üìñ Ver Explica√ß√£o"):
            st.write(feedback["explicacao"])

        # Estat√≠sticas
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Tentativas", feedback["tentativas"])
        with col2:
            st.metric("Pontos", feedback["pontos"])
        with col3:
            tempo = st.session_state.sessao_atual.tempo_fim - st.session_state.sessao_atual.tempo_inicio
            st.metric("Tempo", ".1f")

        # Pr√≥ximo exerc√≠cio sugerido
        if st.button("üéØ Pr√≥ximo Exerc√≠cio", key=f"proximo_{exercicio.id}"):
            # L√≥gica para sugerir pr√≥ximo exerc√≠cio
            st.info("Funcionalidade de sugest√£o ser√° implementada em breve!")

    else:
        st.error("‚ùå **Incorreto.** Tente novamente!")

        # Incrementar tentativa
        st.session_state.tentativa_atual = st.session_state.get('tentativa_atual', 1) + 1

        # Feedback espec√≠fico baseado no tipo
        if exercicio.tipo == TipoExercicio.MULTIPLA_ESCOLHA:
            st.info("üí° Reveja as op√ß√µes e considere a complexidade do algoritmo.")

        # Manter resposta submetida como False para permitir nova tentativa
        st.session_state.resposta_submetida = False

def render_exercicios_por_conceito():
    """Renderiza exerc√≠cios organizados por conceito"""

    st.markdown("### üéØ Exerc√≠cios por Conceito")

    # Selecionar conceito
    conceitos_disponiveis = list(set(
        ex.conceito_relacionado for ex in sistema_exercicios.exercicios.values()
    ))

    conceito_selecionado = st.selectbox(
        "Selecione um conceito:",
        conceitos_disponiveis,
        key="conceito_exercicios"
    )

    if conceito_selecionado:
        exercicios_conceito = sistema_exercicios.obter_exercicios_por_conceito(conceito_selecionado)

        if not exercicios_conceito:
            st.warning(f"Nenhum exerc√≠cio encontrado para o conceito '{conceito_selecionado}'.")
            return

        st.markdown(f"**Encontrados {len(exercicios_conceito)} exerc√≠cios para {conceito_selecionado}:**")

        for exercicio in exercicios_conceito:
            with st.expander(f"üìù {exercicio.titulo}", expanded=False):
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Dificuldade", exercicio.dificuldade.value.title())
                with col2:
                    st.metric("Tipo", exercicio.tipo.value.replace('_', ' ').title())
                with col3:
                    st.metric("Tempo", f"{exercicio.tempo_estimado}min")

                st.write(exercicio.descricao)
                st.write(f"**Enunciado:** {exercicio.enunciado}")

                if st.button(f"üöÄ Praticar: {exercicio.titulo}", key=f"praticar_{exercicio.id}"):
                    # Armazenar exerc√≠cio selecionado e mudar para aba de pr√°tica
                    st.session_state.exercicio_selecionado = exercicio
                    st.success(f"Exerc√≠cio '{exercicio.titulo}' selecionado! V√° para a aba 'Praticar Exerc√≠cios'.")

def render_desempenho_usuario():
    """Renderiza estat√≠sticas de desempenho do usu√°rio"""

    st.markdown("### üìä Meu Desempenho")

    # Calcular estat√≠sticas
    stats = sistema_exercicios.calcular_estatisticas_usuario()

    # M√©tricas principais
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            "Exerc√≠cios Conclu√≠dos",
            f"{stats['exercicios_concluidos']}/{stats['total_exercicios']}"
        )

    with col2:
        st.metric("Taxa de Conclus√£o", ".1f")

    with col3:
        st.metric("Pontos Totais", stats['pontos_totais'])

    with col4:
        st.metric("Tempo Total", ".1f")

    # Gr√°fico de desempenho por tipo
    st.markdown("#### üìà Desempenho por Tipo de Exerc√≠cio")

    tipos_stats = {}
    for sessao in sistema_exercicios.sessoes_ativas.values():
        if sessao.concluido:
            exercicio = sistema_exercicios.exercicios[sessao.exercicio_id]
            tipo = exercicio.tipo.value
            if tipo not in tipos_stats:
                tipos_stats[tipo] = {'concluidos': 0, 'total': 0}
            tipos_stats[tipo]['concluidos'] += 1
            tipos_stats[tipo]['total'] += 1

    # Adicionar tipos n√£o tentados
    for tipo in TipoExercicio:
        if tipo.value not in tipos_stats:
            exercicios_tipo = [ex for ex in sistema_exercicios.exercicios.values() if ex.tipo == tipo]
            tipos_stats[tipo.value] = {'concluidos': 0, 'total': len(exercicios_tipo)}

    # Criar dados para gr√°fico
    tipos_nomes = list(tipos_stats.keys())
    taxas_conclusao = [
        (stats['concluidos'] / stats['total'] * 100) if stats['total'] > 0 else 0
        for stats in tipos_stats.values()
    ]

    import plotly.express as px
    fig = px.bar(
        x=tipos_nomes,
        y=taxas_conclusao,
        title="Taxa de Conclus√£o por Tipo (%)",
        labels={'x': 'Tipo de Exerc√≠cio', 'y': 'Taxa de Conclus√£o (%)'}
    )
    st.plotly_chart(fig, use_container_width=True)

def render_conquistas():
    """Renderiza sistema de conquistas e badges"""

    st.markdown("### üèÜ Conquistas e Badges")

    # Definir conquistas
    conquistas = [
        {
            "titulo": "Primeiros Passos",
            "descricao": "Complete seu primeiro exerc√≠cio",
            "icone": "üéØ",
            "condicao": lambda: len([s for s in sistema_exercicios.sessoes_ativas.values() if s.concluido]) >= 1
        },
        {
            "titulo": "Persistente",
            "descricao": "Tente um exerc√≠cio pelo menos 3 vezes",
            "icone": "üí™",
            "condicao": lambda: any(s.tentativas >= 3 for s in sistema_exercicios.sessoes_ativas.values())
        },
        {
            "titulo": "Perfeccionista",
            "descricao": "Acerte um exerc√≠cio na primeira tentativa",
            "icone": "‚≠ê",
            "condicao": lambda: any(s.tentativas == 1 and s.concluido for s in sistema_exercicios.sessoes_ativas.values())
        },
        {
            "titulo": "Explorador",
            "descricao": "Pratique exerc√≠cios de 3 tipos diferentes",
            "icone": "üó∫Ô∏è",
            "condicao": lambda: len(set(
                sistema_exercicios.exercicios[s.exercicio_id].tipo
                for s in sistema_exercicios.sessoes_ativas.values() if s.concluido
            )) >= 3
        }
    ]

    # Verificar conquistas desbloqueadas
    conquistas_desbloqueadas = []
    conquistas_bloqueadas = []

    for conquista in conquistas:
        if conquista["condicao"]():
            conquistas_desbloqueadas.append(conquista)
        else:
            conquistas_bloqueadas.append(conquista)

    # Exibir conquistas desbloqueadas
    if conquistas_desbloqueadas:
        st.markdown("#### ‚úÖ Conquistas Desbloqueadas")
        for conquista in conquistas_desbloqueadas:
            col1, col2 = st.columns([1, 4])
            with col1:
                st.markdown(f"# {conquista['icone']}")
            with col2:
                st.markdown(f"**{conquista['titulo']}**")
                st.write(conquista['descricao'])

    # Exibir conquistas bloqueadas
    if conquistas_bloqueadas:
        st.markdown("#### üîí Conquistas Dispon√≠veis")
        for conquista in conquistas_bloqueadas:
            col1, col2 = st.columns([1, 4])
            with col1:
                st.markdown(f"# ‚ö´")
            with col2:
                st.markdown(f"**{conquista['titulo']}**")
                st.write(conquista['descricao'])
