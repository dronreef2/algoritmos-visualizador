#!/usr/bin/env python3
"""
Integra√ß√£o com GitHub API - Acesso inteligente √† documenta√ß√£o GitHub
Permite acesso direto √† documenta√ß√£o e c√≥digo de reposit√≥rios GitHub
"""

import os
import sys
import json
import requests
import base64
from typing import Dict, List, Optional, Any

class GitHubDocsClient:
    """
    Cliente para acesso √† documenta√ß√£o GitHub
    Usa API do GitHub para obter README e documenta√ß√£o
    """

    def __init__(self, github_token: str = None):
        """
        Inicializa o cliente GitHub

        Args:
            github_token: Token do GitHub (opcional, aumenta limite de requests)
        """
        self.base_url = "https://api.github.com"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Algoritmos-Visualizador/1.0',
            'Accept': 'application/vnd.github.v3+json'
        })

        # Prioriza st.secrets (Streamlit Cloud), depois par√¢metro, depois vari√°vel de ambiente
        token = None
        if github_token:
            token = github_token
        else:
            # Tenta carregar do st.secrets (Streamlit Cloud)
            try:
                import streamlit as st
                if hasattr(st, 'secrets'):
                    try:
                        token = st.secrets.get('GITHUB_TOKEN')
                    except Exception:
                        # Handle missing secrets gracefully
                        pass
            except ImportError:
                pass

            # Fallback para vari√°vel de ambiente
            if not token:
                token = os.getenv('GITHUB_TOKEN')

        if token:
            self.session.headers['Authorization'] = f'token {token}'

    def is_available(self) -> bool:
        """
        Verifica se a API do GitHub est√° dispon√≠vel

        Returns:
            bool: True se a API estiver acess√≠vel
        """
        try:
            response = self.session.get(f"{self.base_url}/rate_limit", timeout=5)
            return response.status_code == 200
        except:
            return False

    def get_repository_info(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Obt√©m informa√ß√µes b√°sicas de um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com informa√ß√µes do reposit√≥rio
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            return {
                "status": "success",
                "name": data.get("name"),
                "full_name": data.get("full_name"),
                "description": data.get("description"),
                "language": data.get("language"),
                "stars": data.get("stargazers_count"),
                "forks": data.get("forks_count"),
                "topics": data.get("topics", []),
                "html_url": data.get("html_url"),
                "updated_at": data.get("updated_at")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao obter informa√ß√µes do reposit√≥rio"
            }

    def get_readme(self, owner: str, repo: str) -> Dict[str, Any]:
        """
        Obt√©m o README de um reposit√≥rio

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio

        Returns:
            Dict com conte√∫do do README
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}/readme"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            content = data.get("content", "")

            # Decodifica base64 se necess√°rio
            if data.get("encoding") == "base64":
                content = base64.b64decode(content).decode('utf-8')

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "filename": data.get("name", "README.md"),
                "content": content,
                "size": data.get("size", 0),
                "download_url": data.get("download_url")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao obter README"
            }

    def search_code(self, owner: str, repo: str, query: str,
                   language: str = None, max_results: int = 5) -> Dict[str, Any]:
        """
        Busca c√≥digo em um reposit√≥rio usando a API do GitHub

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            query: Termo de busca no c√≥digo
            language: Linguagem de programa√ß√£o (opcional)
            max_results: N√∫mero m√°ximo de resultados

        Returns:
            Dict com resultados da busca de c√≥digo
        """
        try:
            url = f"{self.base_url}/search/code"
            params = {
                'q': f'repo:{owner}/{repo} {query}',
                'per_page': max_results
            }

            if language:
                params['q'] += f' language:{language}'

            response = self.session.get(url, params=params, timeout=15)
            response.raise_for_status()

            data = response.json()
            items = data.get("items", [])

            # Processa os resultados
            results = []
            for item in items:
                results.append({
                    "name": item.get("name"),
                    "path": item.get("path"),
                    "url": item.get("html_url"),
                    "repository": item.get("repository", {}).get("full_name"),
                    "score": item.get("score", 0)
                })

            return {
                "status": "success",
                "query": query,
                "repository": f"{owner}/{repo}",
                "language": language,
                "results": results,
                "total_results": len(results),
                "github_total": data.get("total_count", 0)
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "query": query,
                "repository": f"{owner}/{repo}",
                "error": str(e),
                "message": "Erro ao buscar c√≥digo"
            }

    def get_file_content(self, owner: str, repo: str, path: str) -> Dict[str, Any]:
        """
        Obt√©m conte√∫do de um arquivo espec√≠fico

        Args:
            owner: Propriet√°rio do reposit√≥rio
            repo: Nome do reposit√≥rio
            path: Caminho do arquivo

        Returns:
            Dict com conte√∫do do arquivo
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            content = data.get("content", "")

            # Decodifica base64 se necess√°rio
            if data.get("encoding") == "base64":
                content = base64.b64decode(content).decode('utf-8')

            return {
                "status": "success",
                "repository": f"{owner}/{repo}",
                "path": path,
                "name": data.get("name"),
                "content": content,
                "size": data.get("size", 0),
                "download_url": data.get("download_url")
            }

        except requests.exceptions.RequestException as e:
            return {
                "status": "error",
                "repository": f"{owner}/{repo}",
                "path": path,
                "error": str(e),
                "message": "Erro ao obter conte√∫do do arquivo"
            }


class GitMCPIntegration:
    """
    Integra√ß√£o completa para acesso √† documenta√ß√£o GitHub
    """

    def __init__(self):
        self.client = GitHubDocsClient()
        self.cache = {}

    def buscar_documentacao_algoritmo(self, algoritmo: str,
                                    linguagem: str = "python") -> Dict[str, Any]:
        """
        Busca documenta√ß√£o espec√≠fica para algoritmos

        Args:
            algoritmo: Nome do algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com documenta√ß√£o encontrada
        """
        print(f"üîç Buscando documenta√ß√£o para: {algoritmo} ({linguagem})")

        # Mapeamento de algoritmos para reposit√≥rios relevantes
        repos_map = {
            "sort": ["TheAlgorithms/Python", "keon/algorithms"],
            "search": ["TheAlgorithms/Python", "keon/algorithms"],
            "graph": ["TheAlgorithms/Python", "networkx/networkx"],
            "tree": ["TheAlgorithms/Python", "keon/algorithms"],
            "dynamic": ["TheAlgorithms/Python", "keon/algorithms"],
            "machine_learning": ["scikit-learn/scikit-learn", "tensorflow/tensorflow"]
        }

        algoritmo_key = algoritmo.lower().replace(" ", "_")
        repos = repos_map.get(algoritmo_key, ["TheAlgorithms/Python"])

        resultados = []

        for repo_full in repos:
            if "/" in repo_full:
                owner, repo = repo_full.split("/", 1)
            else:
                continue

            # Obt√©m informa√ß√µes do reposit√≥rio
            repo_info = self.client.get_repository_info(owner, repo)
            readme = self.client.get_readme(owner, repo)

            if repo_info["status"] == "success":
                resultados.append({
                    "repositorio": repo_full,
                    "info": repo_info,
                    "readme": readme if readme["status"] == "success" else None
                })

        return {
            "algoritmo": algoritmo,
            "linguagem": linguagem,
            "resultados": resultados,
            "total_encontrados": len(resultados)
        }

    def obter_exemplos_codigo(self, conceito: str, linguagem: str = "python") -> Dict[str, Any]:
        """
        Obt√©m exemplos de c√≥digo para um conceito espec√≠fico

        Args:
            conceito: Conceito ou algoritmo
            linguagem: Linguagem de programa√ß√£o

        Returns:
            Dict com exemplos de c√≥digo
        """
        print(f"üíª Buscando exemplos para: {conceito} ({linguagem})")

        # Busca nos reposit√≥rios mais relevantes
        repos = ["TheAlgorithms/Python", "keon/algorithms"]

        exemplos = []

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)

            # Busca c√≥digo
            code_search = self.client.search_code(
                owner, repo, conceito, language=linguagem, max_results=5
            )

            if code_search["status"] == "success" and code_search["results"]:
                # Para cada resultado, obt√©m o conte√∫do completo
                for result in code_search["results"]:
                    file_content = self.client.get_file_content(owner, repo, result["path"])
                    if file_content["status"] == "success":
                        exemplos.append({
                            "repositorio": repo_full,
                            "arquivo": result["name"],
                            "caminho": result["path"],
                            "url": result["url"],
                            "conteudo": file_content["content"],
                            "score": result["score"]
                        })

        return {
            "conceito": conceito,
            "linguagem": linguagem,
            "exemplos": exemplos[:10],  # Limita a 10 exemplos
            "total_exemplos": len(exemplos)
        }

    def comparar_implementacoes(self, algoritmo: str) -> Dict[str, Any]:
        """
        Compara diferentes implementa√ß√µes de um algoritmo

        Args:
            algoritmo: Nome do algoritmo

        Returns:
            Dict com compara√ß√µes de implementa√ß√µes
        """
        print(f"üîÑ Comparando implementa√ß√µes de: {algoritmo}")

        repos = ["TheAlgorithms/Python", "keon/algorithms"]

        comparacoes = {}

        for repo_full in repos:
            owner, repo = repo_full.split("/", 1)
            linguagem = "python"  # Ambos s√£o Python

            # Busca implementa√ß√£o
            search = self.client.search_code(owner, repo, algoritmo, max_results=3)

            if search["status"] == "success" and search["results"]:
                if linguagem not in comparacoes:
                    comparacoes[linguagem] = []

                for result in search["results"]:
                    file_content = self.client.get_file_content(owner, repo, result["path"])
                    if file_content["status"] == "success":
                        comparacoes[linguagem].append({
                            "repositorio": repo_full,
                            "arquivo": result["name"],
                            "conteudo": file_content["content"],
                            "url": result["url"]
                        })

        return {
            "algoritmo": algoritmo,
            "comparacoes": comparacoes,
            "linguagens": list(comparacoes.keys())
        }


# Inst√¢ncia global para uso no projeto
github_client = GitHubDocsClient()
github_integration = GitMCPIntegration()

# Manter compatibilidade com c√≥digo existente
gitmcp_client = github_client
gitmcp_integration = github_integration


def testar_integracao():
    """Testa a integra√ß√£o com GitHub API"""
    print("üß™ Testando Integra√ß√£o GitHub API")
    print("=" * 40)

    # Testa disponibilidade
    print(f"GitHub API dispon√≠vel: {github_client.is_available()}")

    if github_client.is_available():
        # Testa busca de reposit√≥rio
        print("\nüìö Testando busca de reposit√≥rio...")
        repo = github_client.get_repository_info("TheAlgorithms", "Python")
        print(f"Status: {repo['status']}")
        if repo['status'] == 'success':
            print(f"üìñ Reposit√≥rio: {repo.get('full_name')}")
            print(f"‚≠ê Stars: {repo.get('stars')}")
            print(f"üìù Descri√ß√£o: {repo.get('description', 'N/A')[:100]}...")

        # Testa busca de README
        print("\nüìÑ Testando busca de README...")
        readme = github_client.get_readme("TheAlgorithms", "Python")
        print(f"Status: {readme['status']}")
        if readme['status'] == 'success':
            content = readme.get('content', '')
            print(f"üìè Tamanho: {len(content)} caracteres")
            print(f"üìÑ Conte√∫do (primeiras 200 chars): {content[:200]}...")

        # Testa busca de c√≥digo
        print("\nüíª Testando busca de c√≥digo...")
        code = github_client.search_code("TheAlgorithms", "Python", "bubble sort", max_results=3)
        print(f"Status: {code['status']}")
        print(f"Resultados encontrados: {code.get('total_results', 0)}")

        # Testa integra√ß√£o espec√≠fica
        print("\nüîó Testando integra√ß√£o de algoritmos...")
        integration = GitMCPIntegration()
        exemplos = integration.obter_exemplos_codigo("quick sort")
        print(f"Exemplos encontrados: {exemplos.get('total_exemplos', 0)}")

    else:
        print("GitHub API n√£o est√° dispon√≠vel no momento")
        print("Verifique sua conex√£o com a internet")


if __name__ == "__main__":
    testar_integracao()
